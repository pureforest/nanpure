<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚«ãƒ©ãƒ¼æ•°ç‹¬ - Color Sudoku</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0f0f1e;
            --bg-light: #1a1a2e;
            --text: #e8f0ff;
            --text-dim: #8b9dc3;
            --grid-line: #2d3350;
            --grid-thick: #4a5280;
            --cell-bg: #16213e;
            --cell-hover: #1e2d4f;
            --cell-selected: #2a3f6f;
            --border-glow: rgba(255, 255, 255, 0.1);
        }

        /* è‰²é‰›ç­†ãƒ¢ãƒ¼ãƒ‰ç”¨ã®æ˜ã‚‹ã„ã‚«ãƒ©ãƒ¼ */
        body.pencil-mode {
            --bg-dark: #fef9f3;
            --bg-light: #fff5eb;
            --text: #2c3e50;
            --text-dim: #5a6c7d;
            --grid-line: #d4c5b9;
            --grid-thick: #a89080;
            --cell-bg: #ffffff;
            --cell-hover: #fff8f0;
            --cell-selected: #ffe8d6;
            --border-glow: rgba(0, 0, 0, 0.05);
        }

        /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒã‚ªãƒ³ï¼‰ã®9è‰² */
        .color-1 { background: linear-gradient(135deg, #ff6b6b, #ee5a6f); }
        .color-2 { background: linear-gradient(135deg, #4ecdc4, #44a6b5); }
        .color-3 { background: linear-gradient(135deg, #ffd93d, #f4a300); }
        .color-4 { background: linear-gradient(135deg, #a8e6cf, #7bc96f); }
        .color-5 { background: linear-gradient(135deg, #ffb3c1, #ff8fa3); }
        .color-6 { background: linear-gradient(135deg, #b4a7d6, #9b89c9); }
        .color-7 { background: linear-gradient(135deg, #fff4a3, #ffe680); }
        .color-8 { background: linear-gradient(135deg, #95e1d3, #6fcfbd); }
        .color-9 { background: linear-gradient(135deg, #ff5470, #e63956); }

        /* è‰²é‰›ç­†ãƒ¢ãƒ¼ãƒ‰ç”¨ã®9è‰²ï¼ˆæŸ”ã‚‰ã‹ãæ˜ã‚‹ã„è‰²ï¼‰ */
        body.pencil-mode .color-1 { background: linear-gradient(135deg, #ff9999, #ffb3b3); }
        body.pencil-mode .color-2 { background: linear-gradient(135deg, #8dd3c7, #a8e6cf); }
        body.pencil-mode .color-3 { background: linear-gradient(135deg, #ffeb99, #fff4b3); }
        body.pencil-mode .color-4 { background: linear-gradient(135deg, #b8e6b8, #d4f1d4); }
        body.pencil-mode .color-5 { background: linear-gradient(135deg, #ffd4e5, #ffe0ed); }
        body.pencil-mode .color-6 { background: linear-gradient(135deg, #d4c5f9, #e6deff); }
        body.pencil-mode .color-7 { background: linear-gradient(135deg, #fff9cc, #fffde6); }
        body.pencil-mode .color-8 { background: linear-gradient(135deg, #b3e5e0, #cff0eb); }
        body.pencil-mode .color-9 { background: linear-gradient(135deg, #ffb3c6, #ffc9d6); }

        body {
            font-family: 'Outfit', sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-light) 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text);
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: absolute;
            width: 1000px;
            height: 1000px;
            background: radial-gradient(circle, rgba(255,107,107,0.15) 0%, transparent 70%);
            top: -500px;
            right: -500px;
            pointer-events: none;
            animation: colorPulse 10s ease-in-out infinite;
        }

        body.pencil-mode::before {
            background: radial-gradient(circle, rgba(255,182,193,0.2) 0%, transparent 70%);
        }

        body::after {
            content: '';
            position: absolute;
            width: 800px;
            height: 800px;
            background: radial-gradient(circle, rgba(78,205,196,0.1) 0%, transparent 70%);
            bottom: -400px;
            left: -400px;
            pointer-events: none;
            animation: colorPulse 12s ease-in-out infinite reverse;
        }

        body.pencil-mode::after {
            background: radial-gradient(circle, rgba(173,216,230,0.15) 0%, transparent 70%);
        }

        @keyframes colorPulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.1); }
        }

        .container {
            max-width: 700px;
            width: 100%;
            animation: fadeIn 0.8s ease-out;
            position: relative;
            z-index: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 50%, #ffe66d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: slideDown 0.6s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 1rem;
            font-weight: 300;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        .tagline {
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-top: 8px;
            font-weight: 400;
        }

        .game-container {
            background: rgba(26, 26, 46, 0.7);
            backdrop-filter: blur(30px);
            border: 1px solid var(--grid-thick);
            border-radius: 24px;
            padding: 35px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5);
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .mode-toggle {
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            background: var(--cell-bg);
            border: 1px solid var(--grid-line);
            border-radius: 12px;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-toggle:hover {
            background: var(--cell-hover);
            border-color: rgba(78, 205, 196, 0.5);
        }

        .mode-toggle.active {
            background: linear-gradient(135deg, #4ecdc4, #44a6b5);
            border-color: #4ecdc4;
            box-shadow: 0 3px 15px rgba(78, 205, 196, 0.3);
        }

        .mode-toggle.active .mode-toggle-label {
            color: white;
        }

        .mode-toggle-icon {
            font-size: 1.2rem;
        }

        .mode-toggle-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .difficulty-btn {
            font-family: 'Outfit', sans-serif;
            padding: 10px 25px;
            border: 1px solid var(--grid-line);
            border-radius: 12px;
            background: var(--cell-bg);
            color: var(--text-dim);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover {
            background: var(--cell-hover);
            border-color: rgba(78, 205, 196, 0.5);
            transform: translateY(-2px);
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            border-color: #ff6b6b;
            color: white;
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.3);
        }

        .grid-wrapper {
            position: relative;
            padding: 3px;
            background: var(--grid-thick);
            border-radius: 12px;
            margin: 25px 0;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 1px;
            background: var(--grid-line);
            border-radius: 10px;
            overflow: hidden;
        }

        .cell {
            aspect-ratio: 1;
            background: var(--cell-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            font-weight: 600;
            font-size: 1.5rem;
        }

        .cell:hover {
            background: var(--cell-hover);
        }

        .cell.selected {
            background: var(--cell-selected);
            box-shadow: inset 0 0 0 2px rgba(78, 205, 196, 0.5);
        }

        .cell.given {
            cursor: default;
        }

        .cell.conflict {
            animation: shake 0.3s ease;
        }

        .cell.conflict .cell-color {
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.8);
        }

        .cell.correct .cell-color {
            animation: pulse 0.5s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        /* 3x3ãƒ–ãƒ­ãƒƒã‚¯ã®å¤ªã„ç½«ç·š */
        .cell:nth-child(3n) { border-right: 2px solid var(--grid-thick); }
        .cell:nth-child(9n) { border-right: none; }
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid var(--grid-thick);
        }

        .cell-color {
            width: 70%;
            height: 70%;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .cell-number {
            position: absolute;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        body.number-mode .cell-color {
            display: none;
        }

        body.number-mode .cell-number {
            display: block;
        }

        body:not(.number-mode) .cell-number {
            display: none;
        }

        /* å€™è£œãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .cell-candidates {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 90%;
            height: 90%;
            position: absolute;
            top: 5%;
            left: 5%;
        }

        .candidate-item {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.55rem;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .candidate-item.active {
            opacity: 1;
        }

        .candidate-item .candidate-color {
            width: 60%;
            height: 60%;
            border-radius: 3px;
        }

        .candidate-item .candidate-number {
            display: none;
            font-size: 0.6rem;
            color: var(--text-dim);
        }

        body.number-mode .candidate-item .candidate-color {
            display: none;
        }

        body.number-mode .candidate-item .candidate-number {
            display: block;
        }

        .color-palette {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .palette-btn {
            width: 42px;
            height: 42px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .palette-btn:hover {
            transform: translateY(-3px) scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .palette-btn.clear {
            background: var(--cell-bg);
            border: 2px solid var(--grid-line);
            color: var(--text-dim);
            font-size: 1.3rem;
            font-weight: 700;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* ãƒ‘ãƒ¬ãƒƒãƒˆãƒœã‚¿ãƒ³ã®æ•°å­—è¡¨ç¤º */
        .palette-number {
            display: none;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* æ•°å­—ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒ‘ãƒ¬ãƒƒãƒˆ */
        body.number-mode .palette-btn:not(.clear) {
            background: var(--cell-bg) !important;
            border: 2px solid var(--grid-line);
        }

        body.number-mode .palette-btn:not(.clear) .palette-number {
            display: block;
        }

        body.number-mode .palette-btn:not(.clear):hover {
            background: var(--cell-hover) !important;
            border-color: rgba(78, 205, 196, 0.5);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            font-family: 'Outfit', sans-serif;
            padding: 12px 30px;
            border: none;
            border-radius: 12px;
            background: var(--cell-bg);
            color: var(--text);
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 1px solid var(--grid-line);
        }

        .control-btn:hover {
            background: var(--cell-hover);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .control-btn.new-game {
            background: linear-gradient(135deg, #4ecdc4, #44a6b5);
            border: none;
        }

        .control-btn.new-game:hover {
            background: linear-gradient(135deg, #5ed9d0, #52b4c3);
        }

        .timer {
            text-align: center;
            font-size: 2rem;
            font-weight: 300;
            color: var(--text-dim);
            margin-top: 20px;
            font-variant-numeric: tabular-nums;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(20px);
            padding: 50px 70px;
            border-radius: 24px;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s ease;
            border: 1px solid var(--grid-thick);
            z-index: 1000;
        }

        .message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .message h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .message p {
            color: var(--text-dim);
            font-size: 1.1rem;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading.show {
            opacity: 1;
            pointer-events: auto;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--grid-line);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading p {
            margin-top: 20px;
            color: var(--text-dim);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ãƒ‡ãƒãƒƒã‚°æƒ…å ± */
        .debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 9999;
            display: none;
        }

        .debug-info.show {
            display: block;
        }

        @media (max-width: 500px) {
            h1 { font-size: 2.5rem; }
            .game-container { padding: 20px; }
            .cell { font-size: 1.1rem; }
            .palette-btn { width: 36px; height: 36px; }
            .control-btn { padding: 10px 20px; font-size: 0.85rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ã‚«ãƒ©ãƒ¼æ•°ç‹¬</h1>
            <p class="subtitle">Color Sudoku</p>
            <p class="tagline">æ•°å­—ã®ä»£ã‚ã‚Šã«è‰²ã‚’ä½¿ã£ãŸæ•°ç‹¬ãƒ‘ã‚ºãƒ«</p>
        </header>

        <div class="game-container">
            <div class="difficulty-selector">
                <button class="difficulty-btn active" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
                <div class="mode-toggle" id="modeToggle">
                    <span class="mode-toggle-icon">ğŸ¨</span>
                    <span class="mode-toggle-label">ãƒã‚ªãƒ³</span>
                </div>
                <div class="mode-toggle" id="displayModeToggle">
                    <span class="mode-toggle-icon">ğŸ¨</span>
                    <span class="mode-toggle-label">è‰²</span>
                </div>
                <div class="mode-toggle" id="candidateToggle">
                    <span class="mode-toggle-icon">âœï¸</span>
                    <span class="mode-toggle-label">å€™è£œ</span>
                </div>
            </div>

            <div class="grid-wrapper">
                <div class="grid" id="grid"></div>
            </div>

            <div class="color-palette" id="colorPalette">
                <button class="palette-btn color-1" data-color="1"><span class="palette-number">1</span></button>
                <button class="palette-btn color-2" data-color="2"><span class="palette-number">2</span></button>
                <button class="palette-btn color-3" data-color="3"><span class="palette-number">3</span></button>
                <button class="palette-btn color-4" data-color="4"><span class="palette-number">4</span></button>
                <button class="palette-btn color-5" data-color="5"><span class="palette-number">5</span></button>
                <button class="palette-btn color-6" data-color="6"><span class="palette-number">6</span></button>
                <button class="palette-btn color-7" data-color="7"><span class="palette-number">7</span></button>
                <button class="palette-btn color-8" data-color="8"><span class="palette-number">8</span></button>
                <button class="palette-btn color-9" data-color="9"><span class="palette-number">9</span></button>
                <button class="palette-btn clear" data-color="0">Ã—</button>
            </div>

            <div class="controls">
                <button class="control-btn" id="checkBtn">ãƒã‚§ãƒƒã‚¯</button>
                <button class="control-btn" id="hintBtn">ãƒ’ãƒ³ãƒˆ</button>
                <button class="control-btn new-game" id="newGameBtn">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button>
            </div>

            <div class="timer" id="timer">00:00</div>
        </div>
    </div>

    <div class="message" id="message">
        <h2>ğŸ¨ å®Œæˆï¼</h2>
        <p>ç´ æ™´ã‚‰ã—ã„è‰²å½©æ„Ÿè¦šã§ã™ï¼</p>
    </div>

    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <p>å•é¡Œã‚’ç”Ÿæˆä¸­...</p>
    </div>

    <div class="debug-info" id="debugInfo"></div>

    <script>
        // ============================================================
        // æ”¹è‰¯ã•ã‚ŒãŸæ•°ç‹¬ç”Ÿæˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        // å‚è€ƒ: https://blog.dnpp.org/number_place_algorithm
        // ============================================================

        // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆURLã«?debug=1ã‚’ä»˜ã‘ã‚‹ã¨æœ‰åŠ¹ï¼‰
        const DEBUG = new URLSearchParams(window.location.search).has('debug');

        function debugLog(msg) {
            if (DEBUG) {
                console.log(msg);
                const debugInfo = document.getElementById('debugInfo');
                debugInfo.classList.add('show');
                debugInfo.innerHTML = msg.replace(/\n/g, '<br>');
            }
        }

        // é–¢é€£ã™ã‚‹ãƒã‚¹ã®åº§æ¨™ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆé«˜é€ŸåŒ–ã®ãŸã‚ï¼‰
        const relatedPositionsCache = [];
        for (let row = 0; row < 9; row++) {
            relatedPositionsCache[row] = [];
            for (let col = 0; col < 9; col++) {
                const positions = [];
                // åŒã˜è¡Œ
                for (let c = 0; c < 9; c++) {
                    if (c !== col) positions.push([row, c]);
                }
                // åŒã˜åˆ—
                for (let r = 0; r < 9; r++) {
                    if (r !== row) positions.push([r, col]);
                }
                // åŒã˜ãƒ–ãƒ­ãƒƒã‚¯
                const blockRow = Math.floor(row / 3) * 3;
                const blockCol = Math.floor(col / 3) * 3;
                for (let r = blockRow; r < blockRow + 3; r++) {
                    for (let c = blockCol; c < blockCol + 3; c++) {
                        if (r !== row && c !== col) {
                            const exists = positions.some(([pr, pc]) => pr === r && pc === c);
                            if (!exists) positions.push([r, c]);
                        }
                    }
                }
                relatedPositionsCache[row][col] = positions;
            }
        }

        // é–¢é€£ã™ã‚‹ãƒã‚¹ã®åº§æ¨™ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ï¼‰
        function getRelatedPositions(row, col) {
            return relatedPositionsCache[row][col];
        }

        // ãƒã‚¹ã«å…¥ã‚‹å€™è£œã‚’è¨ˆç®—ï¼ˆé«˜é€ŸåŒ–ç‰ˆï¼‰
        function getCandidates(grid, row, col) {
            // ãƒ–ãƒ­ã‚°ã®æ‰‹æ³•: ã‚½ãƒ¼ãƒˆæ¸ˆã¿é…åˆ—ã‚’ä½¿ã£ã¦å®šæ•°æ™‚é–“ã§å€™è£œã‚’è¨ˆç®—
            const candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            const related = getRelatedPositions(row, col);
            
            for (const [r, c] of related) {
                const value = grid[r][c];
                if (value > 0) {
                    candidates[value - 1] = -1;
                }
            }
            
            return candidates.filter(x => x > 0);
        }

        // é…ç½®ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
        function isValid(grid, row, col, num) {
            const related = getRelatedPositions(row, col);
            for (const [r, c] of related) {
                if (grid[r][c] === num) return false;
            }
            return true;
        }

        // å®Œæˆã—ãŸæ•°ç‹¬ã‚’ç”Ÿæˆï¼ˆDFSã§æ¢ç´¢ï¼‰
        function generateCompleteSudoku() {
            const grid = Array(9).fill(null).map(() => Array(9).fill(0));
            
            // æœ€åˆã®è¡Œã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«åŸ‹ã‚ã‚‹ï¼ˆãƒ–ãƒ­ã‚°ã®æ‰‹æ³•ï¼‰
            const firstRow = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);
            for (let i = 0; i < 9; i++) {
                grid[0][i] = firstRow[i];
            }
            
            // DFSã§æ®‹ã‚Šã‚’åŸ‹ã‚ã‚‹
            function fillGrid(pos) {
                if (pos === 81) return true;
                
                const row = Math.floor(pos / 9);
                const col = pos % 9;
                
                // æœ€åˆã®è¡Œã¯ã‚¹ã‚­ãƒƒãƒ—
                if (row === 0) return fillGrid(pos + 1);
                
                const candidates = getCandidates(grid, row, col);
                
                // å€™è£œãŒãªã„å ´åˆã¯æåˆˆã‚Š
                if (candidates.length === 0) return false;
                
                // ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸¦ã³æ›¿ãˆ
                candidates.sort(() => Math.random() - 0.5);
                
                for (const num of candidates) {
                    grid[row][col] = num;
                    if (fillGrid(pos + 1)) return true;
                    grid[row][col] = 0;
                }
                
                return false;
            }
            
            fillGrid(0);
            return grid;
        }

        // ============================================================
        // äººé–“çš„ãªä¸å®Œå…¨ã‚½ãƒ«ãƒãƒ¼ï¼ˆãƒ–ãƒ­ã‚°ã®æ‰‹æ³•ï¼‰
        // ============================================================
        function solveHumanLike(grid) {
            const workGrid = JSON.parse(JSON.stringify(grid));
            
            // å„ãƒã‚¹ã®å€™è£œã‚’ç®¡ç†
            const candidates = Array(9).fill(null).map(() => 
                Array(9).fill(null).map(() => new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]))
            );
            
            // ç¢ºå®šå€¤ã‹ã‚‰å€™è£œã‚’å‰Šé™¤
            function updateCandidates(row, col, num) {
                candidates[row][col].clear();
                const related = getRelatedPositions(row, col);
                for (const [r, c] of related) {
                    candidates[r][c].delete(num);
                }
            }
            
            // åˆæœŸçŠ¶æ…‹ã®å€™è£œã‚’æ›´æ–°
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (workGrid[r][c] !== 0) {
                        updateCandidates(r, c, workGrid[r][c]);
                    }
                }
            }
            
            let changed = true;
            let iterations = 0;
            const maxIterations = 100;
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                
                // ãƒ•ã‚§ãƒ¼ã‚º1: å€™è£œãŒ1ã¤ã ã‘ã®ãƒã‚¹ã‚’åŸ‹ã‚ã‚‹ï¼ˆNaked Singleï¼‰
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (workGrid[r][c] === 0 && candidates[r][c].size === 1) {
                            const num = Array.from(candidates[r][c])[0];
                            workGrid[r][c] = num;
                            updateCandidates(r, c, num);
                            changed = true;
                        }
                    }
                }
                
                // ãƒ•ã‚§ãƒ¼ã‚º2: è¡Œãƒ»åˆ—ãƒ»ãƒ–ãƒ­ãƒƒã‚¯å†…ã§1ç®‡æ‰€ã«ã—ã‹å…¥ã‚‰ãªã„æ•°å­—ã‚’æ¢ã™ï¼ˆHidden Singleï¼‰
                for (let num = 1; num <= 9; num++) {
                    // è¡Œã”ã¨
                    for (let r = 0; r < 9; r++) {
                        const possibleCols = [];
                        for (let c = 0; c < 9; c++) {
                            if (workGrid[r][c] === 0 && candidates[r][c].has(num)) {
                                possibleCols.push(c);
                            }
                        }
                        if (possibleCols.length === 1) {
                            const c = possibleCols[0];
                            workGrid[r][c] = num;
                            updateCandidates(r, c, num);
                            changed = true;
                        }
                    }
                    
                    // åˆ—ã”ã¨
                    for (let c = 0; c < 9; c++) {
                        const possibleRows = [];
                        for (let r = 0; r < 9; r++) {
                            if (workGrid[r][c] === 0 && candidates[r][c].has(num)) {
                                possibleRows.push(r);
                            }
                        }
                        if (possibleRows.length === 1) {
                            const r = possibleRows[0];
                            workGrid[r][c] = num;
                            updateCandidates(r, c, num);
                            changed = true;
                        }
                    }
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã”ã¨
                    for (let br = 0; br < 3; br++) {
                        for (let bc = 0; bc < 3; bc++) {
                            const possiblePos = [];
                            for (let r = br * 3; r < br * 3 + 3; r++) {
                                for (let c = bc * 3; c < bc * 3 + 3; c++) {
                                    if (workGrid[r][c] === 0 && candidates[r][c].has(num)) {
                                        possiblePos.push([r, c]);
                                    }
                                }
                            }
                            if (possiblePos.length === 1) {
                                const [r, c] = possiblePos[0];
                                workGrid[r][c] = num;
                                updateCandidates(r, c, num);
                                changed = true;
                            }
                        }
                    }
                }
            }
            
            // ã™ã¹ã¦åŸ‹ã¾ã£ãŸã‹ãƒã‚§ãƒƒã‚¯
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (workGrid[r][c] === 0) return null;
                }
            }
            
            return workGrid;
        }

        // ============================================================
        // è§£ã®æ•°ã‚’æ•°ãˆã‚‹ï¼ˆæœ€å¤§2ã¤ã¾ã§ã€æ—©æœŸæ‰“ã¡åˆ‡ã‚Šï¼‰
        // ============================================================
        function countSolutions(grid, maxCount = 2) {
            let count = 0;
            const workGrid = JSON.parse(JSON.stringify(grid));
            
            // ã¾ãšäººé–“çš„ãªã‚½ãƒ«ãƒãƒ¼ã§è§£ã‘ã‚‹éƒ¨åˆ†ã‚’è§£ãï¼ˆæåˆˆã‚Šã¨ã—ã¦æ©Ÿèƒ½ï¼‰
            const candidates = Array(9).fill(null).map(() => 
                Array(9).fill(null).map(() => new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]))
            );
            
            // åˆæœŸå€™è£œã‚’è¨­å®š
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (workGrid[r][c] !== 0) {
                        candidates[r][c].clear();
                        const related = getRelatedPositions(r, c);
                        for (const [rr, cc] of related) {
                            candidates[rr][cc].delete(workGrid[r][c]);
                        }
                    }
                }
            }
            
            function solve(pos) {
                if (count >= maxCount) return;
                
                // æ¬¡ã®ç©ºããƒã‚¹ã‚’æ¢ã™
                while (pos < 81) {
                    const row = Math.floor(pos / 9);
                    const col = pos % 9;
                    if (workGrid[row][col] === 0) break;
                    pos++;
                }
                
                if (pos === 81) {
                    count++;
                    return;
                }
                
                const row = Math.floor(pos / 9);
                const col = pos % 9;
                
                // å€™è£œã‚’å–å¾—
                const possibleNums = [];
                for (let num = 1; num <= 9; num++) {
                    if (isValid(workGrid, row, col, num)) {
                        possibleNums.push(num);
                    }
                }
                
                // å€™è£œãŒãªã„å ´åˆã¯æåˆˆã‚Š
                if (possibleNums.length === 0) return;
                
                for (const num of possibleNums) {
                    if (count >= maxCount) return;
                    workGrid[row][col] = num;
                    solve(pos + 1);
                    workGrid[row][col] = 0;
                }
            }
            
            solve(0);
            return count;
        }

        // ============================================================
        // å•é¡Œç”Ÿæˆï¼ˆãƒ–ãƒ­ã‚°ã®æ‰‹æ³•ã«åŸºã¥ãæ”¹è‰¯ç‰ˆï¼‰
        // ============================================================
        function generatePuzzle(difficulty) {
            const maxAttempts = 30;
            
            // é›£æ˜“åº¦ã«å¿œã˜ãŸè¨­å®š
            const config = {
                easy: { 
                    targetBlanks: 28,     // åˆæœŸé…ç½®53ï¼ˆãƒ–ãƒ­ã‚°ã®åˆå¿ƒè€…ãƒ¬ãƒ™ãƒ«ï¼‰
                    minBlanks: 25,
                    requireHumanSolvable: true
                },
                medium: { 
                    targetBlanks: 44,     // åˆæœŸé…ç½®37ï¼ˆãƒ–ãƒ­ã‚°ã®ä¸­ç´šãƒ¬ãƒ™ãƒ«ï¼‰
                    minBlanks: 40,
                    requireHumanSolvable: true
                },
                hard: { 
                    targetBlanks: 56,     // é™ç•Œã¾ã§ç©ºã‘ã‚‹ï¼ˆãƒ–ãƒ­ã‚°ã®ä¸Šç´šãƒ¬ãƒ™ãƒ«ï¼‰
                    minBlanks: 50,
                    requireHumanSolvable: false  // å…¨æ¢ç´¢ãŒå¿…è¦ãªå•é¡Œã‚‚è¨±å¯
                }
            }[difficulty];
            
            debugLog(`ç”Ÿæˆé–‹å§‹: ${difficulty}, ç›®æ¨™ç©ºããƒã‚¹: ${config.targetBlanks}`);
            
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const solution = generateCompleteSudoku();
                const puzzle = JSON.parse(JSON.stringify(solution));
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªé †åºã§ç©´ã‚’ç©ºã‘ã¦ã„ã
                const positions = [];
                for (let i = 0; i < 81; i++) positions.push(i);
                positions.sort(() => Math.random() - 0.5);
                
                let blanks = 0;
                let skipped = 0;
                
                for (const pos of positions) {
                    if (blanks >= config.targetBlanks) break;
                    
                    const row = Math.floor(pos / 9);
                    const col = pos % 9;
                    const backup = puzzle[row][col];
                    
                    puzzle[row][col] = 0;
                    
                    // è§£ãŒä¸€æ„ã‹ãƒã‚§ãƒƒã‚¯
                    const solutionCount = countSolutions(puzzle, 2);
                    
                    if (solutionCount === 1) {
                        // Easy/Mediumã¯äººé–“çš„ãªè§£æ³•ã§è§£ã‘ã‚‹ã“ã¨ã‚’ç¢ºèª
                        if (config.requireHumanSolvable) {
                            const humanSolution = solveHumanLike(puzzle);
                            if (humanSolution) {
                                blanks++;
                            } else {
                                // äººé–“çš„ãªè§£æ³•ã§ã¯è§£ã‘ãªã„ã®ã§å…ƒã«æˆ»ã™
                                puzzle[row][col] = backup;
                                skipped++;
                            }
                        } else {
                            blanks++;
                        }
                    } else {
                        // è¤‡æ•°è§£ã¾ãŸã¯è§£ãªã—
                        puzzle[row][col] = backup;
                    }
                }
                
                debugLog(`è©¦è¡Œ ${attempt + 1}: ç©ºããƒã‚¹ ${blanks}, ã‚¹ã‚­ãƒƒãƒ— ${skipped}`);
                
                // ç›®æ¨™ã«é”ã—ãŸå ´åˆã¯æ¡ç”¨
                if (blanks >= config.minBlanks) {
                    debugLog(`æˆåŠŸ: ç©ºããƒã‚¹ ${blanks}`);
                    return { puzzle, solution };
                }
            }
            
            // æœ€å¤§è©¦è¡Œå›æ•°ã‚’è¶…ãˆãŸå ´åˆã¯æœ€å¾Œã«æˆåŠŸã—ãŸçµæœã‚’è¿”ã™
            debugLog('æœ€å¤§è©¦è¡Œå›æ•°ã«é”ã—ã¾ã—ãŸã€‚å†ç”Ÿæˆ...');
            return generatePuzzle(difficulty);
        }

        // ============================================================
        // ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯
        // ============================================================

        let currentPuzzle = [];
        let currentSolution = [];
        let initialPuzzle = [];
        let currentCandidates = Array(9).fill(null).map(() => Array(9).fill(null).map(() => new Set()));
        let selectedCell = null;
        let difficulty = 'easy';
        let startTime = null;
        let timerInterval = null;
        let isPencilMode = false;
        let isNumberMode = false;
        let isCandidateMode = false;

        // ã‚°ãƒªãƒƒãƒ‰ã®åˆæœŸåŒ–
        function initGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.addEventListener('click', () => selectCell(i));
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'cell-color';
                cell.appendChild(colorDiv);
                
                const numberDiv = document.createElement('div');
                numberDiv.className = 'cell-number';
                cell.appendChild(numberDiv);
                
                // å€™è£œè¡¨ç¤ºç”¨
                const candidatesDiv = document.createElement('div');
                candidatesDiv.className = 'cell-candidates';
                for (let n = 1; n <= 9; n++) {
                    const candidateItem = document.createElement('div');
                    candidateItem.className = 'candidate-item';
                    candidateItem.dataset.num = n;
                    
                    const candidateColor = document.createElement('div');
                    candidateColor.className = `candidate-color color-${n}`;
                    candidateItem.appendChild(candidateColor);
                    
                    const candidateNumber = document.createElement('span');
                    candidateNumber.className = 'candidate-number';
                    candidateNumber.textContent = n;
                    candidateItem.appendChild(candidateNumber);
                    
                    candidatesDiv.appendChild(candidateItem);
                }
                cell.appendChild(candidatesDiv);
                
                grid.appendChild(cell);
            }
        }

        // ã‚»ãƒ«ã®é¸æŠ
        function selectCell(index) {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(c => c.classList.remove('selected'));
            
            const cell = cells[index];
            if (!cell.classList.contains('given')) {
                cell.classList.add('selected');
                selectedCell = index;
            }
        }

        // ã‚°ãƒªãƒƒãƒ‰ã®æç”»
        function renderGrid() {
            const cells = document.querySelectorAll('.cell');
            
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 9);
                const col = index % 9;
                const value = currentPuzzle[row][col];
                const colorDiv = cell.querySelector('.cell-color');
                const numberDiv = cell.querySelector('.cell-number');
                const candidatesDiv = cell.querySelector('.cell-candidates');
                
                // è‰²ã‚’ã‚¯ãƒªã‚¢
                colorDiv.className = 'cell-color';
                numberDiv.textContent = '';
                
                // å€™è£œã‚’ã‚¯ãƒªã‚¢
                const candidateItems = candidatesDiv.querySelectorAll('.candidate-item');
                candidateItems.forEach(item => item.classList.remove('active'));
                
                if (value > 0) {
                    colorDiv.classList.add(`color-${value}`);
                    numberDiv.textContent = value;
                    candidatesDiv.style.display = 'none';
                } else {
                    candidatesDiv.style.display = 'grid';
                    // å€™è£œã‚’è¡¨ç¤º
                    const cellCandidates = currentCandidates[row][col];
                    cellCandidates.forEach(num => {
                        const item = candidatesDiv.querySelector(`[data-num="${num}"]`);
                        if (item) item.classList.add('active');
                    });
                }
                
                // åˆæœŸé…ç½®ã®ãƒã‚¹ã‚’ãƒãƒ¼ã‚¯
                if (initialPuzzle[row][col] > 0) {
                    cell.classList.add('given');
                } else {
                    cell.classList.remove('given');
                }
            });
        }

        // æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹
        function startNewGame() {
            const loading = document.getElementById('loading');
            loading.classList.add('show');
            
            // éåŒæœŸã§å•é¡Œã‚’ç”Ÿæˆï¼ˆUIã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ãŸã‚ï¼‰
            setTimeout(() => {
                const result = generatePuzzle(difficulty);
                currentPuzzle = JSON.parse(JSON.stringify(result.puzzle));
                currentSolution = result.solution;
                initialPuzzle = JSON.parse(JSON.stringify(result.puzzle));
                
                // å€™è£œã‚’ã‚¯ãƒªã‚¢
                currentCandidates = Array(9).fill(null).map(() => 
                    Array(9).fill(null).map(() => new Set())
                );
                
                selectedCell = null;
                document.getElementById('message').classList.remove('show');
                
                renderGrid();
                startTimer();
                
                loading.classList.remove('show');
            }, 50);
        }

        // è‰²ã‚’å…¥åŠ›
        function inputColor(color) {
            if (selectedCell === null) return;
            
            const row = Math.floor(selectedCell / 9);
            const col = selectedCell % 9;
            const cell = document.querySelectorAll('.cell')[selectedCell];
            
            if (cell.classList.contains('given')) return;
            
            if (isCandidateMode && color > 0) {
                // å€™è£œãƒ¢ãƒ¼ãƒ‰
                if (currentCandidates[row][col].has(color)) {
                    currentCandidates[row][col].delete(color);
                } else {
                    currentCandidates[row][col].add(color);
                }
                currentPuzzle[row][col] = 0;
            } else {
                // ç¢ºå®šãƒ¢ãƒ¼ãƒ‰
                if (color === 0) {
                    currentPuzzle[row][col] = 0;
                } else if (currentPuzzle[row][col] === color) {
                    currentPuzzle[row][col] = 0;
                } else {
                    currentPuzzle[row][col] = color;
                }
                currentCandidates[row][col].clear();
            }
            
            cell.classList.remove('conflict');
            renderGrid();
            checkCompletion();
        }

        // ç«¶åˆã‚’ãƒã‚§ãƒƒã‚¯
        function checkConflicts() {
            const cells = document.querySelectorAll('.cell');
            let hasConflict = false;
            
            cells.forEach(c => c.classList.remove('conflict'));
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const value = currentPuzzle[row][col];
                    if (value === 0) continue;
                    
                    for (let c = 0; c < 9; c++) {
                        if (c !== col && currentPuzzle[row][c] === value) {
                            cells[row * 9 + col].classList.add('conflict');
                            cells[row * 9 + c].classList.add('conflict');
                            hasConflict = true;
                        }
                    }
                    
                    for (let r = 0; r < 9; r++) {
                        if (r !== row && currentPuzzle[r][col] === value) {
                            cells[row * 9 + col].classList.add('conflict');
                            cells[r * 9 + col].classList.add('conflict');
                            hasConflict = true;
                        }
                    }
                    
                    const blockRow = Math.floor(row / 3) * 3;
                    const blockCol = Math.floor(col / 3) * 3;
                    for (let r = blockRow; r < blockRow + 3; r++) {
                        for (let c = blockCol; c < blockCol + 3; c++) {
                            if (r !== row && c !== col && currentPuzzle[r][c] === value) {
                                cells[row * 9 + col].classList.add('conflict');
                                cells[r * 9 + c].classList.add('conflict');
                                hasConflict = true;
                            }
                        }
                    }
                }
            }
            
            return hasConflict;
        }

        // å®Œæˆã‚’ãƒã‚§ãƒƒã‚¯
        function checkCompletion() {
            let isComplete = true;
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (currentPuzzle[row][col] === 0) {
                        isComplete = false;
                        break;
                    }
                }
                if (!isComplete) break;
            }
            
            if (isComplete && !checkConflicts()) {
                stopTimer();
                setTimeout(() => {
                    document.getElementById('message').classList.add('show');
                }, 400);
            }
        }

        // ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º
        function showHint() {
            const emptyCells = [];
            
            for (let i = 0; i < 81; i++) {
                const row = Math.floor(i / 9);
                const col = i % 9;
                if (currentPuzzle[row][col] === 0) {
                    emptyCells.push(i);
                }
            }
            
            if (emptyCells.length === 0) return;
            
            const randomIndex = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            const row = Math.floor(randomIndex / 9);
            const col = randomIndex % 9;
            const color = currentSolution[row][col];
            
            currentPuzzle[row][col] = color;
            currentCandidates[row][col].clear();
            
            const cells = document.querySelectorAll('.cell');
            cells[randomIndex].classList.add('correct');
            
            renderGrid();
            checkCompletion();
        }

        // ã‚¿ã‚¤ãƒãƒ¼
        function startTimer() {
            stopTimer();
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `${minutes}:${seconds}`;
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '9') {
                inputColor(parseInt(e.key));
            } else if (e.key === '0' || e.key === 'Backspace' || e.key === 'Delete') {
                inputColor(0);
            }
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                difficulty = btn.dataset.difficulty;
                startNewGame();
            });
        });

        document.querySelectorAll('.palette-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const color = parseInt(btn.dataset.color);
                inputColor(color);
            });
        });

        document.getElementById('newGameBtn').addEventListener('click', () => {
            document.getElementById('message').classList.remove('show');
            startNewGame();
        });

        document.getElementById('checkBtn').addEventListener('click', checkConflicts);
        document.getElementById('hintBtn').addEventListener('click', showHint);

        // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        document.getElementById('modeToggle').addEventListener('click', () => {
            isPencilMode = !isPencilMode;
            const body = document.body;
            const modeLabel = document.querySelector('#modeToggle .mode-toggle-label');
            const modeIcon = document.querySelector('#modeToggle .mode-toggle-icon');
            const modeToggle = document.getElementById('modeToggle');
            
            if (isPencilMode) {
                body.classList.add('pencil-mode');
                modeLabel.textContent = 'è‰²é‰›ç­†';
                modeIcon.textContent = 'âœï¸';
                modeToggle.classList.add('active');
            } else {
                body.classList.remove('pencil-mode');
                modeLabel.textContent = 'ãƒã‚ªãƒ³';
                modeIcon.textContent = 'ğŸ¨';
                modeToggle.classList.remove('active');
            }
        });

        document.getElementById('displayModeToggle').addEventListener('click', () => {
            isNumberMode = !isNumberMode;
            const body = document.body;
            const displayModeToggle = document.getElementById('displayModeToggle');
            const modeLabel = displayModeToggle.querySelector('.mode-toggle-label');
            const modeIcon = displayModeToggle.querySelector('.mode-toggle-icon');
            
            if (isNumberMode) {
                body.classList.add('number-mode');
                modeLabel.textContent = 'æ•°å­—';
                modeIcon.textContent = 'ğŸ”¢';
                displayModeToggle.classList.add('active');
            } else {
                body.classList.remove('number-mode');
                modeLabel.textContent = 'è‰²';
                modeIcon.textContent = 'ğŸ¨';
                displayModeToggle.classList.remove('active');
            }
            
            renderGrid();
        });

        document.getElementById('candidateToggle').addEventListener('click', () => {
            isCandidateMode = !isCandidateMode;
            const candidateToggle = document.getElementById('candidateToggle');
            const modeLabel = candidateToggle.querySelector('.mode-toggle-label');
            const modeIcon = candidateToggle.querySelector('.mode-toggle-icon');
            
            if (isCandidateMode) {
                modeLabel.textContent = 'å€™è£œ';
                modeIcon.textContent = 'âœï¸';
                candidateToggle.classList.add('active');
            } else {
                modeLabel.textContent = 'ç¢ºå®š';
                modeIcon.textContent = 'âœ“';
                candidateToggle.classList.remove('active');
            }
        });

        // åˆæœŸåŒ–
        initGrid();
        startNewGame();
    </script>
</body>
</html>
